---
sidebar_label: array
sidebar_position: 1
---

陣列（Array）

在 JavaScript 中，陣列（Array）是一種非常常用的資料結構，用於儲存一系列的元素。與其他語言類似，JavaScript 陣列中的每個元素都可以通過索引值來訪問，並且可以進行新增、修改、尋找等操作。

以下是一個使用 JavaScript 實現的陣列例子：

```jsx
javascriptCopy code
let arr = [1, 2, 3, 4, 5]; // 定義一個有 5 個元素的整數陣列
let sum = 0;

// 遍歷陣列，計算元素總和
for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
}

console.log(`The sum of array elements is: ${sum}`); // 輸出元素總和

```

在這個例子中，我們首先定義了一個有 5 個元素的整數陣列，然後使用 for 循環遍歷陣列，計算元素總和。注意，在 JavaScript 中，可以使用陣列的 length 屬性獲取陣列的元素個數。最後，我們使用 console.log() 函數輸出元素總和。

| 方法 | 最壞時間複雜度 | 說明 |
| --- | --- | --- |
| push() | O(1) | 在陣列末尾新增一個元素，所需時間與陣列的大小無關，因此時間複雜度為常數級別的 O(1)。 |
| pop() | O(1) | 從陣列末尾刪除一個元素，所需時間與陣列的大小無關，因此時間複雜度為常數級別的 O(1)。 |
| shift() | O(n) | 從陣列開頭刪除一個元素，需要將陣列中的元素進行移動，所需時間與陣列大小成正比，因此時間複雜度為 O(n)。 |
| unshift() | O(n) | 在陣列開頭新增一個元素，需要將陣列中的元素進行移動，所需時間與陣列大小成正比，因此時間複雜度為 O(n)。 |
| splice() | O(n) | 在指定位置新增或刪除元素，需要將陣列中的元素進行移動，所需時間與陣列大小成正比，因此時間複雜度為 O(n)。 |
| slice() | O(n) | 返回一個新的陣列，包含從開始索引到結束索引（不包括結束索引）之間的元素。需要複製一份子陣列，因此時間複雜度為 O(n)。 |
| sort() | O(n log n) | 使用快速排序等演算法對陣列進行排序，時間複雜度為 O(n log n)。 |
| reverse() | O(n) | 反轉陣列中的元素，時間複雜度為 O(n)。 |
| concat() | O(m + n) | 將兩個陣列合併為一個新的陣列，需要創建一個新的陣列並將兩個陣列的元素複製到新的陣列中，因此時間複雜度為 O(m + n)。 |
| join() | O(n) | 將陣列中的元素連接為一個字串，需要遍歷陣列中的元素，時間複雜度為 O(n)。 |
| toString() | O(n) | 返回一個字串，其中包含陣列中的所有元素。需要遍歷陣列中的元素，時間複雜度為 O(n)。 |
| indexOf() | O(n) | 在陣列中尋找一個元素，需要遍歷整個陣列，時間複雜度為 O |
| lastIndexOf() | O(n) | 在陣列中從後往前尋找指定元素，需要遍歷整個陣列。 |
| filter() | O(n) | 返回符合條件的所有元素，需要遍歷整個陣列。 |
| map() | O(n) | 返回由原陣列中的每個元素按照指定規則運算後的結果組成的新陣列，需要遍歷整個陣列。 |
| reduce() | O(n) | 將陣列中的元素按照指定規則運算，需要遍歷整個陣列。 |
| forEach() | O(n) | 遍歷陣列中的每個元素，需要遍歷整個陣列。 |
| every() | O(n) | 遍歷陣列中的每個元素，直到有一個元素不滿足條件，需要遍歷整個陣列。 |
| some() | O(n) | 遍歷陣列中的每個元素，直到有一個元素符合條件，需要遍歷整個陣列。 |

在這個表格中，n 表示陣列的元素個數，m 表示另一個陣列的元素個數（如果有）。可以看出，大多數 JavaScript 陣列方法的時間複雜度是 O(n)，其中一些操作，如 shift() 和 unshift() 的時間複雜度更高，達到了 O(n)。然而，一些方法，如 push() 和 pop()，的時間複雜度非常低，僅為 O(1)。

在實際開發中，我們需要根據演算法和應用場景的需要選擇適當的方法來操作陣列，以保證效率和性能。